---
title: 使用记录类型 - C# 教程
description: 了解如何使用记录类型、构建记录的层次结构，以及何时选择记录而不是类。
ms.date: 11/12/2020
ms.openlocfilehash: c8a1922fdf113d046dc087ec289accce4312c4ae
ms.sourcegitcommit: 4b7f6b348c986556ef805cb6baacfd5b9ec18ed0
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/08/2021
ms.locfileid: "107075532"
---
# <a name="create-record-types"></a><span data-ttu-id="2440a-103">创建记录类型</span><span class="sxs-lookup"><span data-stu-id="2440a-103">Create record types</span></span>

<span data-ttu-id="2440a-104">C# 9 引入了 [*记录*](../../language-reference/builtin-types/record.md)，这是一种可以创建的新引用类型，而不是类或结构。</span><span class="sxs-lookup"><span data-stu-id="2440a-104">C# 9 introduces [*records*](../../language-reference/builtin-types/record.md), a new reference type that you can create instead of classes or structs.</span></span> <span data-ttu-id="2440a-105">记录与类不同，区别在于记录类型使用基于值的相等性。</span><span class="sxs-lookup"><span data-stu-id="2440a-105">Records are distinct from classes in that record types use *value-based equality*.</span></span> <span data-ttu-id="2440a-106">两个记录类型的变量在它们的类型和值都相同时，它们是相等的。</span><span class="sxs-lookup"><span data-stu-id="2440a-106">Two variables of a record type are equal if the record type definitions are identical, and if for every field, the values in both records are equal.</span></span> <span data-ttu-id="2440a-107">两个类类型的变量如果引用的对象属于同一类类型并且引用相同的对象，则这两个变量是相等的。</span><span class="sxs-lookup"><span data-stu-id="2440a-107">Two variables of a class type are equal if the objects referred to are the same class type and the variables refer to the same object.</span></span> <span data-ttu-id="2440a-108">基于值的相等性意味着可能需要的记录类型中的其他功能。</span><span class="sxs-lookup"><span data-stu-id="2440a-108">Value-based equality implies other capabilities you'll probably want in record types.</span></span> <span data-ttu-id="2440a-109">声明 `record` 而不是 `class` 时，编译器将生成许多这些成员。</span><span class="sxs-lookup"><span data-stu-id="2440a-109">The compiler generates many of those members when you declare a `record` instead of a `class`.</span></span>

<span data-ttu-id="2440a-110">本教程介绍以下操作：</span><span class="sxs-lookup"><span data-stu-id="2440a-110">In this tutorial, you'll learn how to:</span></span>

> [!div class="checklist"]
>
> - <span data-ttu-id="2440a-111">决定是否应声明 `class` 或 `record`。</span><span class="sxs-lookup"><span data-stu-id="2440a-111">Decide if you should declare a `class` or a `record`.</span></span>
> - <span data-ttu-id="2440a-112">声明记录类型和位置记录类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-112">Declare record types and positional record types.</span></span>
> - <span data-ttu-id="2440a-113">在记录中将你的方法替换为编译器生成的方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-113">Substitute your methods for compiler generated methods in records.</span></span>

## <a name="prerequisites"></a><span data-ttu-id="2440a-114">必备条件</span><span class="sxs-lookup"><span data-stu-id="2440a-114">Prerequisites</span></span>

<span data-ttu-id="2440a-115">需要将计算机设置为运行 .NET 5 或更高版本，包括 C# 9.0 或更高版本编译器。</span><span class="sxs-lookup"><span data-stu-id="2440a-115">You'll need to set up your machine to run .NET 5 or later, including the C# 9.0 or later compiler.</span></span> <span data-ttu-id="2440a-116">自 [Visual Studio 2019 版本 16.8](https://visualstudio.microsoft.com/vs) 或 [.NET 5.0 SDK](https://dotnet.microsoft.com/download) 起，开始随附 C# 9.0 编译器。</span><span class="sxs-lookup"><span data-stu-id="2440a-116">The C# 9.0 compiler is available starting with [Visual Studio 2019 version 16.8](https://visualstudio.microsoft.com/vs) or the [.NET 5.0 SDK](https://dotnet.microsoft.com/download).</span></span>

## <a name="characteristics-of-records"></a><span data-ttu-id="2440a-117">记录的特征</span><span class="sxs-lookup"><span data-stu-id="2440a-117">Characteristics of records</span></span>

<span data-ttu-id="2440a-118">通过使用 `record` 关键字（而不是 `class` 或 `struct` 关键字）声明一个类型，可以定义记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-118">You define a *record* by declaring a type with the `record` keyword, instead of the `class` or `struct` keyword.</span></span> <span data-ttu-id="2440a-119">记录是一种引用类型并遵循基于值的相等性语义。</span><span class="sxs-lookup"><span data-stu-id="2440a-119">A record is a reference type and follows value-based equality semantics.</span></span> <span data-ttu-id="2440a-120">为了强制执行值语义，编译器将为记录类型生成多种方法：</span><span class="sxs-lookup"><span data-stu-id="2440a-120">To enforce value semantics, the compiler generates several methods for your record type:</span></span>

- <span data-ttu-id="2440a-121"><xref:System.Object.Equals(System.Object)?displayProperty=nameWithType> 的替代。</span><span class="sxs-lookup"><span data-stu-id="2440a-121">An override of <xref:System.Object.Equals(System.Object)?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="2440a-122">一个虚拟的 `Equals` 方法，其参数为记录类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-122">A virtual `Equals` method whose parameter is the record type.</span></span>
- <span data-ttu-id="2440a-123"><xref:System.Object.GetHashCode?displayProperty=nameWithType> 的替代。</span><span class="sxs-lookup"><span data-stu-id="2440a-123">An override of <xref:System.Object.GetHashCode?displayProperty=nameWithType>.</span></span>
- <span data-ttu-id="2440a-124">用于 `operator ==` 和 `operator !=` 的方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-124">Methods for `operator ==` and `operator !=`.</span></span>
- <span data-ttu-id="2440a-125">记录类型实现 <xref:System.IEquatable%601?displayProperty=nameWithType>。</span><span class="sxs-lookup"><span data-stu-id="2440a-125">Record types implement <xref:System.IEquatable%601?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="2440a-126">此外，记录还提供 <xref:System.Object.ToString?displayProperty=nameWithType> 的替代。</span><span class="sxs-lookup"><span data-stu-id="2440a-126">In addition, records provide an override of <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2440a-127">编译器使用 <xref:System.Object.ToString?displayProperty=nameWithType> 合成用于显示记录的方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-127">The compiler synthesizes methods for displaying records using <xref:System.Object.ToString?displayProperty=nameWithType>.</span></span> <span data-ttu-id="2440a-128">在编写本教程的代码时，你将浏览这些成员。</span><span class="sxs-lookup"><span data-stu-id="2440a-128">You'll explore those members as you write the code for this tutorial.</span></span> <span data-ttu-id="2440a-129">记录支持 `with` 表达式，以启用记录的非破坏性修改。</span><span class="sxs-lookup"><span data-stu-id="2440a-129">Records support `with` expressions to enable non-destructive mutation of records.</span></span>

<span data-ttu-id="2440a-130">还可使用更简洁的语法来声明位置记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-130">You can also declare *positional records* using a more concise syntax.</span></span> <span data-ttu-id="2440a-131">声明以下位置记录时，编译器会合成更多方法：</span><span class="sxs-lookup"><span data-stu-id="2440a-131">The compiler synthesizes more methods for you when you declare positional records:</span></span>

- <span data-ttu-id="2440a-132">主构造函数，它的参数与记录声明上的位置参数匹配。</span><span class="sxs-lookup"><span data-stu-id="2440a-132">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
- <span data-ttu-id="2440a-133">主构造函数的每个参数的公共 init-only 属性。</span><span class="sxs-lookup"><span data-stu-id="2440a-133">Public init-only properties for each parameter of a primary constructor.</span></span>
- <span data-ttu-id="2440a-134">用于从记录中提取属性的 `Deconstruct` 方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-134">A `Deconstruct` method to extract properties from the record.</span></span>

## <a name="build-temperature-data"></a><span data-ttu-id="2440a-135">生成温度数据</span><span class="sxs-lookup"><span data-stu-id="2440a-135">Build temperature data</span></span>

<span data-ttu-id="2440a-136">数据和统计信息是你要使用记录时所需的内容。</span><span class="sxs-lookup"><span data-stu-id="2440a-136">Data and statistics are among the scenarios where you'll want to use records.</span></span> <span data-ttu-id="2440a-137">在本教程中，你将构建一个用于计算度日数的应用程序，以用于不同用途。</span><span class="sxs-lookup"><span data-stu-id="2440a-137">For this tutorial, you'll build an application that computes *degree days* for different uses.</span></span> <span data-ttu-id="2440a-138">度日数是反映几天、几周或几个月内采暖（或采暖不足）的度量。</span><span class="sxs-lookup"><span data-stu-id="2440a-138">*Degree days* are a measure of heat (or lack of heat) over a period of days, weeks, or months.</span></span> <span data-ttu-id="2440a-139">度日数可跟踪和预测能源使用情况。</span><span class="sxs-lookup"><span data-stu-id="2440a-139">Degree days track and predict energy usage.</span></span> <span data-ttu-id="2440a-140">高温天数越多表示使用空调的时间越多，降温天数越多意味着使用暖气炉的时间越多。</span><span class="sxs-lookup"><span data-stu-id="2440a-140">More hotter days means more air conditioning, and more colder days means more furnace usage.</span></span> <span data-ttu-id="2440a-141">度日数有助于管理植物种群，并且随着季节的变化，与植物的生长密切相关。</span><span class="sxs-lookup"><span data-stu-id="2440a-141">Degree days help manage plant populations and correlate to plant growth as the seasons change.</span></span> <span data-ttu-id="2440a-142">度日数有助于跟踪动物为适应气候而进行的物种迁徙。</span><span class="sxs-lookup"><span data-stu-id="2440a-142">Degree days help track animal migrations for species that travel to match climate.</span></span>

<span data-ttu-id="2440a-143">此公式基于给定的某一天的平均温度和基准温度。</span><span class="sxs-lookup"><span data-stu-id="2440a-143">The formula is based on the mean temperature on a given day and a baseline temperature.</span></span> <span data-ttu-id="2440a-144">若要计算一段时间内的度日数，需要这段时间的每日最高温度和最低温度。</span><span class="sxs-lookup"><span data-stu-id="2440a-144">To compute degree days over time, you'll need the high and low temperature each day for a period of time.</span></span> <span data-ttu-id="2440a-145">首先，我们要创建一个新的应用程序。</span><span class="sxs-lookup"><span data-stu-id="2440a-145">Let's start by creating a new application.</span></span> <span data-ttu-id="2440a-146">生成新的控制台应用程序。</span><span class="sxs-lookup"><span data-stu-id="2440a-146">Make a new console application.</span></span> <span data-ttu-id="2440a-147">在名为“DailyTemperature.cs”的新文件中创建新的记录类型：</span><span class="sxs-lookup"><span data-stu-id="2440a-147">Create a new record type in a new file named "DailyTemperature.cs":</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DailyRecord":::

<span data-ttu-id="2440a-148">上述代码定义了位置记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-148">The preceding code defines a *positional record*.</span></span> <span data-ttu-id="2440a-149">你已创建包含两个属性（`HighTemp` 和 `LowTemp`）的引用类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-149">You've created a reference type that contains two properties: `HighTemp`, and `LowTemp`.</span></span> <span data-ttu-id="2440a-150">这些属性是 init-only 属性，这意味着可在构造函数中设置它们，或使用属性初始化表达式设置它们。</span><span class="sxs-lookup"><span data-stu-id="2440a-150">Those properties are *init only properties*, meaning they can be set in the constructor or using a property initializer.</span></span> <span data-ttu-id="2440a-151">`DailyTemperature` 类型还有一个主构造函数，该构造函数具有两个与这两个属性匹配的参数。</span><span class="sxs-lookup"><span data-stu-id="2440a-151">The `DailyTemperature` type also has a *primary constructor* that has two parameters that match the two properties.</span></span> <span data-ttu-id="2440a-152">使用该主构造函数初始化 `DailyTemperature` 记录：</span><span class="sxs-lookup"><span data-stu-id="2440a-152">You use the primary constructor to initialize a `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="DeclareData":::

<span data-ttu-id="2440a-153">可将你自己的属性或方法添加到记录，包括位置记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-153">You can add your own properties or methods to records, including positional records.</span></span> <span data-ttu-id="2440a-154">需要计算每天的平均温度。</span><span class="sxs-lookup"><span data-stu-id="2440a-154">You'll need to compute the mean temperature for each day.</span></span> <span data-ttu-id="2440a-155">可将该属性添加到 `DailyTemperature` 记录：</span><span class="sxs-lookup"><span data-stu-id="2440a-155">You can add that property to the `DailyTemperature` record:</span></span>

:::code language="csharp" source="snippets/record-types/DailyTemperature.cs" ID="TemperatureRecord":::

<span data-ttu-id="2440a-156">现在需确保你可以使用此数据。</span><span class="sxs-lookup"><span data-stu-id="2440a-156">Let's make sure you can use this data.</span></span> <span data-ttu-id="2440a-157">将以下代码添加到 `Main` 方法：</span><span class="sxs-lookup"><span data-stu-id="2440a-157">Add the following code to your `Main` method:</span></span>

```csharp
foreach (var item in data)
    Console.WriteLine(item);
```

<span data-ttu-id="2440a-158">运行应用程序，然后你将看到类似于以下显示内容的输出（因空间有限，删除了几行内容）：</span><span class="sxs-lookup"><span data-stu-id="2440a-158">Run your application, and you'll see output that looks similar to the following display (several rows removed for space):</span></span>

```dotnetcli
DailyTemperature { HighTemp = 57, LowTemp = 30, Mean = 43.5 }
DailyTemperature { HighTemp = 60, LowTemp = 35, Mean = 47.5 }


DailyTemperature { HighTemp = 80, LowTemp = 60, Mean = 70 }
DailyTemperature { HighTemp = 85, LowTemp = 66, Mean = 75.5 }
```

<span data-ttu-id="2440a-159">上述代码显示了由编译器合成的 `ToString` 的替代输出。</span><span class="sxs-lookup"><span data-stu-id="2440a-159">The preceding code shows the output from the override of `ToString` synthesized by the compiler.</span></span> <span data-ttu-id="2440a-160">如果希望使用不同的文本，可编写自己的 `ToString` 版本，以防止编译器为你合成一个版本。</span><span class="sxs-lookup"><span data-stu-id="2440a-160">If you prefer different text, you can write your own version of `ToString` that prevents the compiler from synthesizing a version for you.</span></span>

## <a name="compute-degree-days"></a><span data-ttu-id="2440a-161">计算度日数</span><span class="sxs-lookup"><span data-stu-id="2440a-161">Compute degree days</span></span>

<span data-ttu-id="2440a-162">若要计算度日数，需要获得给定的某一天的基准温度和平均温度之间的差额。</span><span class="sxs-lookup"><span data-stu-id="2440a-162">To compute degree days, you take the difference from a baseline temperature and the mean temperature on a given day.</span></span> <span data-ttu-id="2440a-163">若要测量一段时间内的采暖，需要忽略平均温度低于基准温度的任何日期。</span><span class="sxs-lookup"><span data-stu-id="2440a-163">To measure heat over time, you discard any days where the mean temperature is below the baseline.</span></span> <span data-ttu-id="2440a-164">若要测量一段时间内的降温，需要忽略平均温度高于基准温度的任何日期。</span><span class="sxs-lookup"><span data-stu-id="2440a-164">To measure cold over time, you discard any days where the mean temperature is above the baseline.</span></span> <span data-ttu-id="2440a-165">例如，美国使用 65F 作为采暖和制冷度日数的基准。</span><span class="sxs-lookup"><span data-stu-id="2440a-165">For example, the U.S. uses 65F as the base for both heating  and cooling degree days.</span></span> <span data-ttu-id="2440a-166">在此温度下，无需采暖或制冷。</span><span class="sxs-lookup"><span data-stu-id="2440a-166">That's the temperature where no heating or cooling is needed.</span></span> <span data-ttu-id="2440a-167">如果某一天的平均温度为 70F，则这一天的制冷度日数为 5，采暖度日数为 0。</span><span class="sxs-lookup"><span data-stu-id="2440a-167">If a day has a mean temperature of 70F, that day is 5 cooling degree days and 0 heating degree days.</span></span> <span data-ttu-id="2440a-168">相反，如果某一天的平均温度为 55F，则这一天的采暖度日数为 10，制冷度日数为 0。</span><span class="sxs-lookup"><span data-stu-id="2440a-168">Conversely, if the mean temperature is 55F, that day is 10 heating degree days and 0 cooling degree days.</span></span>

<span data-ttu-id="2440a-169">可将这些公式表示为记录类型的小型层次结构：一种抽象度日数类型以及两种具体的采暖度日数和制冷度日数类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-169">You can express these formulas as a small hierarchy of record types: an abstract degree day type and two concrete types for heating degree days and cooling degree days.</span></span> <span data-ttu-id="2440a-170">这些类型也可以是位置记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-170">These types can also be positional records.</span></span> <span data-ttu-id="2440a-171">它们将基准温度和一系列每日温度记录作为主构造函数的参数：</span><span class="sxs-lookup"><span data-stu-id="2440a-171">They take a baseline temperature and a sequence of daily temperature records as arguments to the primary constructor:</span></span>

:::code language="csharp" source="snippets/record-types/InterimSteps.cs" ID="DegreeDaysRecords":::

<span data-ttu-id="2440a-172">抽象的 `DegreeDays` 记录是 `HeatingDegreeDays` 和 `CoolingDegreeDays` 记录的共享基类。</span><span class="sxs-lookup"><span data-stu-id="2440a-172">The abstract `DegreeDays` record is the shared base class for both the `HeatingDegreeDays` and `CoolingDegreeDays` records.</span></span> <span data-ttu-id="2440a-173">派生记录的主构造函数声明显示了如何管理基本记录初始化。</span><span class="sxs-lookup"><span data-stu-id="2440a-173">The primary constructor declarations on the derived records show how to manage base record initialization.</span></span> <span data-ttu-id="2440a-174">派生记录为基本记录主构造函数中的所有参数声明参数。</span><span class="sxs-lookup"><span data-stu-id="2440a-174">Your derived record declares parameters for all the parameters in the base record primary constructor.</span></span> <span data-ttu-id="2440a-175">基本记录声明并初始化这些属性。</span><span class="sxs-lookup"><span data-stu-id="2440a-175">The base record declares and initializes those properties.</span></span> <span data-ttu-id="2440a-176">派生记录不会隐藏它们，而只会创建和初始化未在其基本记录中声明的参数的属性。</span><span class="sxs-lookup"><span data-stu-id="2440a-176">The derived record doesn't hide them, but only creates and initializes properties for parameters that aren't declared in its base record.</span></span> <span data-ttu-id="2440a-177">在此示例中，派生记录不会添加新的主构造函数参数。</span><span class="sxs-lookup"><span data-stu-id="2440a-177">In this example, the derived records don't add new primary constructor parameters.</span></span> <span data-ttu-id="2440a-178">通过将以下代码添加到 `Main` 方法来测试代码：</span><span class="sxs-lookup"><span data-stu-id="2440a-178">Test your code by adding the following code to your `Main` method:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="HeatingAndCooling":::

<span data-ttu-id="2440a-179">将获得类似以下显示内容的输出：</span><span class="sxs-lookup"><span data-stu-id="2440a-179">You'll get output like the following display:</span></span>

```dotnetcli
HeatingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 85 }
CoolingDegreeDays { BaseTemperature = 65, TempRecords = record_types.DailyTemperature[], DegreeDays = 71.5 }
```

## <a name="define-compiler-synthesized-methods"></a><span data-ttu-id="2440a-180">定义编译器合成方法</span><span class="sxs-lookup"><span data-stu-id="2440a-180">Define compiler-synthesized methods</span></span>

<span data-ttu-id="2440a-181">代码将计算该时间段内正确的采暖和制冷度日数。</span><span class="sxs-lookup"><span data-stu-id="2440a-181">Your code calculates the correct number of heating and cooling degree days over that period of time.</span></span> <span data-ttu-id="2440a-182">但此示例展示了为何需要替换记录的某些合成方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-182">But this example shows why you may want to replace some of the synthesized methods for records.</span></span> <span data-ttu-id="2440a-183">可以在记录类型中声明你自己的版本的任意编译器合成方法（clone 方法除外）。</span><span class="sxs-lookup"><span data-stu-id="2440a-183">You can declare your own version of any of the compiler-synthesized methods in a record type except the clone method.</span></span> <span data-ttu-id="2440a-184">clone 方法具有编译器生成的名称，你无法提供不同的实现。</span><span class="sxs-lookup"><span data-stu-id="2440a-184">The clone method has a compiler generated name and you cannot provide a different implementation.</span></span> <span data-ttu-id="2440a-185">这些合成方法包括复制构造函数、<xref:System.IEquatable%601?displayProperty=nameWithType> 接口的成员、相等性和不相等测试以及 <xref:System.Object.GetHashCode>。</span><span class="sxs-lookup"><span data-stu-id="2440a-185">These synthesized methods include a copy constructor, the members of the <xref:System.IEquatable%601?displayProperty=nameWithType> interface, equality and inequality tests, and <xref:System.Object.GetHashCode>.</span></span> <span data-ttu-id="2440a-186">为此，你需要合成 `PrintMembers`。</span><span class="sxs-lookup"><span data-stu-id="2440a-186">For this purpose, you'll synthesize `PrintMembers`.</span></span> <span data-ttu-id="2440a-187">你还可以声明自己的 `ToString`，但 `PrintMembers` 为继承方案提供了更好的选择。</span><span class="sxs-lookup"><span data-stu-id="2440a-187">You could also declare your own `ToString`, but `PrintMembers` provides a better option for inheritance scenarios.</span></span> <span data-ttu-id="2440a-188">若要提供自己的合成方法版本，签名必须与合成方法相匹配。</span><span class="sxs-lookup"><span data-stu-id="2440a-188">To provide your own version of a synthesized method, the signature must match the synthesized method.</span></span>

<span data-ttu-id="2440a-189">控制台输出中的 `TempRecords` 元素不起作用。</span><span class="sxs-lookup"><span data-stu-id="2440a-189">The `TempRecords` element in the console output isn't useful.</span></span> <span data-ttu-id="2440a-190">它只显示类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-190">It displays the type, but nothing else.</span></span> <span data-ttu-id="2440a-191">可通过提供自己的合成 `PrintMembers` 方法的实现来更改此行为。</span><span class="sxs-lookup"><span data-stu-id="2440a-191">You can change this behavior by providing your own implementation of the synthesized `PrintMembers` method.</span></span> <span data-ttu-id="2440a-192">签名取决于应用于 `record` 声明的修饰符：</span><span class="sxs-lookup"><span data-stu-id="2440a-192">The signature depends on modifiers applied to the `record` declaration:</span></span>

- <span data-ttu-id="2440a-193">如果记录类型为 `sealed`，则签名为 `private bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="2440a-193">If a record type is `sealed`, the signature is `private bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="2440a-194">如果记录类型不为 `sealed` 并派生自 `object`（即，它不声明基本记录），则签名为 `protected virtual bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="2440a-194">If a record type isn't `sealed` and derives from `object` (that is, it doesn't declare a base record), the signature is `protected virtual bool PrintMembers(StringBuilder builder);`</span></span>
- <span data-ttu-id="2440a-195">如果记录类型不为 `sealed` 并派生自其他记录，则签名为 `protected override bool PrintMembers(StringBuilder builder);`</span><span class="sxs-lookup"><span data-stu-id="2440a-195">If a record type isn't `sealed` and derives from another record, the signature is `protected override bool PrintMembers(StringBuilder builder);`</span></span>

<span data-ttu-id="2440a-196">了解 `PrintMembers` 的目的之后，就可以轻松地理解这些规则。</span><span class="sxs-lookup"><span data-stu-id="2440a-196">These rules are easiest to comprehend through understanding the purpose of `PrintMembers`.</span></span> <span data-ttu-id="2440a-197">`PrintMembers` 将记录类型中每个属性的相关信息添加到字符串。</span><span class="sxs-lookup"><span data-stu-id="2440a-197">`PrintMembers` adds information about each property in a record type to a string.</span></span> <span data-ttu-id="2440a-198">该协定要求基本记录添加其要显示的成员，并假设派生成员将添加其成员。</span><span class="sxs-lookup"><span data-stu-id="2440a-198">The contract requires base records to add their members to the display and assumes derived members will add their members.</span></span> <span data-ttu-id="2440a-199">每个记录类型都会合成一个 `ToString` 替代，与下面的 `HeatingDegreeDays` 示例类似：</span><span class="sxs-lookup"><span data-stu-id="2440a-199">Each record type synthesizes a `ToString` override that looks similar to the following example for `HeatingDegreeDays`:</span></span>

```csharp
public override string ToString()
{
    StringBuilder stringBuilder = new StringBuilder();
    stringBuilder.Append("HeatingDegreeDays");
    stringBuilder.Append(" { ");
    if (PrintMembers(stringBuilder))
    {
        stringBuilder.Append(" ");
    }
    stringBuilder.Append("}");
    return stringBuilder.ToString();
}
```

<span data-ttu-id="2440a-200">在不打印集合类型的 `DegreeDays` 记录中声明 `PrintMembers` 方法：</span><span class="sxs-lookup"><span data-stu-id="2440a-200">You declare a `PrintMembers` method in the `DegreeDays` record that doesn't print the type of the collection:</span></span>

:::code language="csharp" source="snippets/record-types/DegreeDays.cs" ID="AddPrintMembers":::

<span data-ttu-id="2440a-201">签名声明一个 `virtual protected` 方法来匹配编译器的版本。</span><span class="sxs-lookup"><span data-stu-id="2440a-201">The signature declares a `virtual protected` method to match the compiler's version.</span></span> <span data-ttu-id="2440a-202">如果访问器出错，请不要担心；语言会强制执行正确的签名。</span><span class="sxs-lookup"><span data-stu-id="2440a-202">Don't worry if you get the accessors wrong; the language enforces the correct signature.</span></span> <span data-ttu-id="2440a-203">如果你忘记了任何合成方法的正确修饰符，则编译器会发出警告或错误，帮助你获取正确的签名。</span><span class="sxs-lookup"><span data-stu-id="2440a-203">If you forget the correct modifiers for any synthesized method, the compiler issues warnings or errors that help you get the right signature.</span></span>

## <a name="non-destructive-mutation"></a><span data-ttu-id="2440a-204">非破坏性修改</span><span class="sxs-lookup"><span data-stu-id="2440a-204">Non-destructive mutation</span></span>

<span data-ttu-id="2440a-205">位置记录中的合成成员不会修改记录的状态。</span><span class="sxs-lookup"><span data-stu-id="2440a-205">The synthesized members in a positional record don't modify the state of the record.</span></span> <span data-ttu-id="2440a-206">目的是帮助你更轻松地创建不可变记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-206">The goal is that you can more easily create immutable records.</span></span> <span data-ttu-id="2440a-207">请再次查看前面的关于 `HeatingDegreeDays` 和 `CoolingDegreeDays` 的声明。</span><span class="sxs-lookup"><span data-stu-id="2440a-207">Look again at the preceding declarations for `HeatingDegreeDays` and `CoolingDegreeDays`.</span></span> <span data-ttu-id="2440a-208">添加的成员对记录的值执行计算，但不会改变状态。</span><span class="sxs-lookup"><span data-stu-id="2440a-208">The members added perform computations on the values for the record, but don't mutate state.</span></span> <span data-ttu-id="2440a-209">位置记录使你可以更轻松地创建不可变引用类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-209">Positional records make it easier for you to create immutable reference types.</span></span>

<span data-ttu-id="2440a-210">创建不可变的引用类型意味着需要使用非破坏性修改。</span><span class="sxs-lookup"><span data-stu-id="2440a-210">Creating immutable reference types means you'll want to use non-destructive mutation.</span></span> <span data-ttu-id="2440a-211">使用 [`with` 表达式](../../language-reference/operators/with-expression.md) 创建与现有记录实例类似的新记录实例。</span><span class="sxs-lookup"><span data-stu-id="2440a-211">You  create new record instances that are similar to existing record instances using [`with` expressions](../../language-reference/operators/with-expression.md).</span></span> <span data-ttu-id="2440a-212">这些表达式是一个副本构造，其中包含修改副本的其他赋值。</span><span class="sxs-lookup"><span data-stu-id="2440a-212">These expressions are a copy construction with additional assignments that modify the copy.</span></span> <span data-ttu-id="2440a-213">结果是一个新的记录实例，其中每个属性都已从现有记录进行复制并选择性地进行了修改。</span><span class="sxs-lookup"><span data-stu-id="2440a-213">The result is a new record instance where each property has been copied from the existing record and optionally modified.</span></span> <span data-ttu-id="2440a-214">原始记录未发生更改。</span><span class="sxs-lookup"><span data-stu-id="2440a-214">The original record is unchanged.</span></span>

<span data-ttu-id="2440a-215">让我们向程序添加一些演示 `with` 表达式的功能。</span><span class="sxs-lookup"><span data-stu-id="2440a-215">Let's add a couple features to your program that demonstrate `with` expressions.</span></span> <span data-ttu-id="2440a-216">首先，创建一条新记录，使用相同数据计算增长的度日数。</span><span class="sxs-lookup"><span data-stu-id="2440a-216">First, let's create a new record to compute growing degree days using the same data.</span></span> <span data-ttu-id="2440a-217">增长的度日数通常使用 41F 作为基准，并测量超出基准的温度。</span><span class="sxs-lookup"><span data-stu-id="2440a-217">*Growing degree days* typically uses 41F as the baseline and measures temperatures above the baseline.</span></span> <span data-ttu-id="2440a-218">若要使用相同的数据，可创建一条类似于 `coolingDegreeDays` 的新记录，但基准温度不同：</span><span class="sxs-lookup"><span data-stu-id="2440a-218">To use the same data, you can create a new record that is similar to the `coolingDegreeDays`, but with a different base temperature:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="GrowingDegreeDays":::

<span data-ttu-id="2440a-219">可将计算得出的度数与在较高基准温度下生成的数字进行比较。</span><span class="sxs-lookup"><span data-stu-id="2440a-219">You can compare the number of degrees computed to the numbers generated with a higher baseline temperature.</span></span> <span data-ttu-id="2440a-220">请记住，记录是引用类型，这些副本是浅表副本。</span><span class="sxs-lookup"><span data-stu-id="2440a-220">Remember that records are *reference types* and these copies are shallow copies.</span></span> <span data-ttu-id="2440a-221">不会复制数据的数组，但两条记录都引用相同的数据。</span><span class="sxs-lookup"><span data-stu-id="2440a-221">The array for the data isn't copied, but both records refer to the same data.</span></span> <span data-ttu-id="2440a-222">在另一种场景中，这是一个优势。</span><span class="sxs-lookup"><span data-stu-id="2440a-222">That fact is an advantage in one other scenario.</span></span> <span data-ttu-id="2440a-223">对于增长的度日数，记录前 5 天的总度数非常有用。</span><span class="sxs-lookup"><span data-stu-id="2440a-223">For growing degree days, it's useful to keep track of the total for the previous 5 days.</span></span> <span data-ttu-id="2440a-224">可以使用 `with` 表达式创建具有不同源数据的新记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-224">You can create new records with different source data using `with` expressions.</span></span> <span data-ttu-id="2440a-225">下面的代码将生成这些累计数据的集合，然后显示这些值：</span><span class="sxs-lookup"><span data-stu-id="2440a-225">The following code builds a collection of these accumulations, then displays the values:</span></span>

:::code language="csharp" source="snippets/record-types/Program.cs" ID="RunningFiveDayTotal":::

<span data-ttu-id="2440a-226">还可使用 `with` 表达式来创建记录的副本。</span><span class="sxs-lookup"><span data-stu-id="2440a-226">You can also use `with` expressions to create copies of records.</span></span> <span data-ttu-id="2440a-227">请勿指定 `with` 表达式的大括号之间的任何属性。</span><span class="sxs-lookup"><span data-stu-id="2440a-227">Don't specify any properties between the braces for the `with` expression.</span></span> <span data-ttu-id="2440a-228">这意味着将创建一个副本，并且不会更改任何属性：</span><span class="sxs-lookup"><span data-stu-id="2440a-228">That means create a copy, and don't change any properties:</span></span>

```csharp
var growingDegreeDaysCopy = growingDegreeDays with { };
```

<span data-ttu-id="2440a-229">运行已完成的应用程序以查看结果。</span><span class="sxs-lookup"><span data-stu-id="2440a-229">Run the finished application to see the results.</span></span>

## <a name="summary"></a><span data-ttu-id="2440a-230">总结</span><span class="sxs-lookup"><span data-stu-id="2440a-230">Summary</span></span>

<span data-ttu-id="2440a-231">本教程介绍了记录的几个方面。</span><span class="sxs-lookup"><span data-stu-id="2440a-231">This tutorial showed several aspects of records.</span></span> <span data-ttu-id="2440a-232">记录为引用类型提供了简洁的语法，它的基本用途是存储数据。</span><span class="sxs-lookup"><span data-stu-id="2440a-232">Records provide concise syntax for reference types where the fundamental use is storing data.</span></span> <span data-ttu-id="2440a-233">对于面向对象的类，基本用途是定义责任。</span><span class="sxs-lookup"><span data-stu-id="2440a-233">For object-oriented classes, the fundamental use is defining responsibilities.</span></span> <span data-ttu-id="2440a-234">本教程重点介绍了位置记录，在这种记录中，你可以使用简洁的语法来声明记录的 init-only 属性。</span><span class="sxs-lookup"><span data-stu-id="2440a-234">This tutorial focused on *positional records*, where you can use a concise syntax to declare the init-only properties for a record.</span></span> <span data-ttu-id="2440a-235">编译器会合成记录的多个成员，以复制和比较记录。</span><span class="sxs-lookup"><span data-stu-id="2440a-235">The compiler synthesizes several members of the record for copying and comparing records.</span></span> <span data-ttu-id="2440a-236">你可针对记录类型添加所需的任何其他成员。</span><span class="sxs-lookup"><span data-stu-id="2440a-236">You can add any other members you need for your record types.</span></span> <span data-ttu-id="2440a-237">在明确编译器生成的所有成员都不会改变状态的情况下，可以创建不可变的记录类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-237">You can create immutable record types knowing that none of the compiler-generated members would mutate state.</span></span> <span data-ttu-id="2440a-238">可借助 `with` 表达式轻松实现非破坏性修改。</span><span class="sxs-lookup"><span data-stu-id="2440a-238">And `with` expressions make it easy to support non-destructive mutation.</span></span>

<span data-ttu-id="2440a-239">记录提供了另一种定义类型的方法。</span><span class="sxs-lookup"><span data-stu-id="2440a-239">Records add another way to define types.</span></span> <span data-ttu-id="2440a-240">使用 `class` 定义来创建面向对象的层次结构，这些层次结构重点关注对象的责任和行为。</span><span class="sxs-lookup"><span data-stu-id="2440a-240">You use `class` definitions to create object-oriented hierarchies that focus on the responsibilities and behavior of objects.</span></span> <span data-ttu-id="2440a-241">可为数据结构创建 `struct` 类型，这些数据结构可存储数据，并且足够小，以便进行有效复制。</span><span class="sxs-lookup"><span data-stu-id="2440a-241">You create `struct` types for data structures that store data and are small enough to copy efficiently.</span></span> <span data-ttu-id="2440a-242">当你需要基于值的相等性和比较、不需要复制值以及要使用引用变量时，可以创建 `record` 类型。</span><span class="sxs-lookup"><span data-stu-id="2440a-242">You create `record` types when you want value-based equality and comparison, don't want to copy values, and want to use reference variables.</span></span>

<span data-ttu-id="2440a-243">若要了解记录的完整说明，可阅读[记录类型的 C# 语言参考文章](../../language-reference/builtin-types/record.md)和[建议的记录类型规范](~/_csharplang/proposals/csharp-9.0/records.md)。</span><span class="sxs-lookup"><span data-stu-id="2440a-243">You can learn the complete description of records by reading the [C# language reference article for the record type](../../language-reference/builtin-types/record.md) and the [proposed record type specification](~/_csharplang/proposals/csharp-9.0/records.md).</span></span>
