---
title: C# 9.0 中的新增功能 - C# 指南
description: 简要介绍 C# 9.0 中提供的新功能。
ms.date: 04/07/2021
ms.openlocfilehash: c2189d2db175a40c24d6a41d20f2ae2d9384513b
ms.sourcegitcommit: e7e0921d0a10f85e9cb12f8b87cc1639a6c8d3fe
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 04/09/2021
ms.locfileid: "107255332"
---
# <a name="whats-new-in-c-90"></a><span data-ttu-id="7dc70-103">C# 9.0 中的新增功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-103">What's new in C# 9.0</span></span>

<span data-ttu-id="7dc70-104">C# 9.0 向 C# 语言添加了以下功能和增强功能：</span><span class="sxs-lookup"><span data-stu-id="7dc70-104">C# 9.0 adds the following features and enhancements to the C# language:</span></span>

- [<span data-ttu-id="7dc70-105">记录</span><span class="sxs-lookup"><span data-stu-id="7dc70-105">Records</span></span>](#record-types)
- [<span data-ttu-id="7dc70-106">仅限 Init 的资源库</span><span class="sxs-lookup"><span data-stu-id="7dc70-106">Init only setters</span></span>](#init-only-setters)
- [<span data-ttu-id="7dc70-107">顶级语句</span><span class="sxs-lookup"><span data-stu-id="7dc70-107">Top-level statements</span></span>](#top-level-statements)
- [<span data-ttu-id="7dc70-108">模式匹配增强功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-108">Pattern matching enhancements</span></span>](#pattern-matching-enhancements)
- [<span data-ttu-id="7dc70-109">性能和互操作性</span><span class="sxs-lookup"><span data-stu-id="7dc70-109">Performance and interop</span></span>](#performance-and-interop)
  - <span data-ttu-id="7dc70-110">本机大小的整数</span><span class="sxs-lookup"><span data-stu-id="7dc70-110">Native sized integers</span></span>
  - <span data-ttu-id="7dc70-111">函数指针</span><span class="sxs-lookup"><span data-stu-id="7dc70-111">Function pointers</span></span>
  - <span data-ttu-id="7dc70-112">禁止发出 localsinit 标志</span><span class="sxs-lookup"><span data-stu-id="7dc70-112">Suppress emitting localsinit flag</span></span>
- [<span data-ttu-id="7dc70-113">调整和完成功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-113">Fit and finish features</span></span>](#fit-and-finish-features)
  - <span data-ttu-id="7dc70-114">目标类型的 `new` 表达式</span><span class="sxs-lookup"><span data-stu-id="7dc70-114">Target-typed `new` expressions</span></span>
  - <span data-ttu-id="7dc70-115">静态匿名函数</span><span class="sxs-lookup"><span data-stu-id="7dc70-115">static anonymous functions</span></span>
  - <span data-ttu-id="7dc70-116">目标类型的条件表达式</span><span class="sxs-lookup"><span data-stu-id="7dc70-116">Target-typed conditional expressions</span></span>
  - <span data-ttu-id="7dc70-117">协变返回类型</span><span class="sxs-lookup"><span data-stu-id="7dc70-117">Covariant return types</span></span>
  - <span data-ttu-id="7dc70-118">扩展 `GetEnumerator` 支持 `foreach` 循环</span><span class="sxs-lookup"><span data-stu-id="7dc70-118">Extension `GetEnumerator` support for `foreach` loops</span></span>
  - <span data-ttu-id="7dc70-119">Lambda 弃元参数</span><span class="sxs-lookup"><span data-stu-id="7dc70-119">Lambda discard parameters</span></span>
  - <span data-ttu-id="7dc70-120">本地函数的属性</span><span class="sxs-lookup"><span data-stu-id="7dc70-120">Attributes on local functions</span></span>
- [<span data-ttu-id="7dc70-121">支持代码生成器</span><span class="sxs-lookup"><span data-stu-id="7dc70-121">Support for code generators</span></span>](#support-for-code-generators)
  - <span data-ttu-id="7dc70-122">模块初始值设定项</span><span class="sxs-lookup"><span data-stu-id="7dc70-122">Module initializers</span></span>
  - <span data-ttu-id="7dc70-123">分部方法的新功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-123">New features for partial methods</span></span>

<span data-ttu-id="7dc70-124">.NET 5 支持 C# 9.0。</span><span class="sxs-lookup"><span data-stu-id="7dc70-124">C# 9.0 is supported on **.NET 5**.</span></span> <span data-ttu-id="7dc70-125">有关详细信息，请参阅 [C# 语言版本控制](../language-reference/configure-language-version.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-125">For more information, see [C# language versioning](../language-reference/configure-language-version.md).</span></span>

<span data-ttu-id="7dc70-126">可以从 [.NET 下载页](https://dotnet.microsoft.com/download)下载最新 .NET SDK。</span><span class="sxs-lookup"><span data-stu-id="7dc70-126">You can download the latest .NET SDK from the [.NET downloads page](https://dotnet.microsoft.com/download).</span></span>

## <a name="record-types"></a><span data-ttu-id="7dc70-127">记录类型</span><span class="sxs-lookup"><span data-stu-id="7dc70-127">Record types</span></span>

<span data-ttu-id="7dc70-128">C# 9.0 引入了记录类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-128">C# 9.0 introduces ***record types***.</span></span> <span data-ttu-id="7dc70-129">可使用 `record` 关键字定义一个引用类型，用来提供用于封装数据的内置功能。</span><span class="sxs-lookup"><span data-stu-id="7dc70-129">You use the `record` keyword to define a reference type that provides built-in functionality for encapsulating data.</span></span> <span data-ttu-id="7dc70-130">通过使用位置参数或标准属性语法，可以创建具有不可变属性的记录类型：</span><span class="sxs-lookup"><span data-stu-id="7dc70-130">You can create record types with immutable properties by using positional parameters or standard property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalRecord":::
:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ImmutableRecord":::

<span data-ttu-id="7dc70-131">此外，还可以创建具有可变属性和字段的记录类型：</span><span class="sxs-lookup"><span data-stu-id="7dc70-131">You can also create record types with mutable properties and fields:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="MutableRecord":::

<span data-ttu-id="7dc70-132">虽然记录可以是可变的，但它们主要用于支持不可变的数据模型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-132">While records can be mutable, they are primarily intended for supporting immutable data models.</span></span> <span data-ttu-id="7dc70-133">记录类型提供以下功能：</span><span class="sxs-lookup"><span data-stu-id="7dc70-133">The record type offers the following features:</span></span>

* [<span data-ttu-id="7dc70-134">用于创建具有不可变属性的引用类型的简明语法</span><span class="sxs-lookup"><span data-stu-id="7dc70-134">Concise syntax for creating a reference type with immutable properties</span></span>](#positional-syntax-for-property-definition)
* <span data-ttu-id="7dc70-135">行为对于以数据为中心的引用类型非常有用：</span><span class="sxs-lookup"><span data-stu-id="7dc70-135">Behavior useful for a data-centric reference type:</span></span>
  * [<span data-ttu-id="7dc70-136">值相等性</span><span class="sxs-lookup"><span data-stu-id="7dc70-136">Value equality</span></span>](#value-equality)
  * [<span data-ttu-id="7dc70-137">非破坏性变化的简明语法</span><span class="sxs-lookup"><span data-stu-id="7dc70-137">Concise syntax for nondestructive mutation</span></span>](#nondestructive-mutation)
  * [<span data-ttu-id="7dc70-138">用于显示的内置格式设置</span><span class="sxs-lookup"><span data-stu-id="7dc70-138">Built-in formatting for display</span></span>](#built-in-formatting-for-display)
* [<span data-ttu-id="7dc70-139">支持继承层次结构</span><span class="sxs-lookup"><span data-stu-id="7dc70-139">Support for inheritance hierarchies</span></span>](#inheritance)

<span data-ttu-id="7dc70-140">可使用[结构类型](../language-reference/builtin-types/struct.md)来设计以数据为中心的类型，这些类型提供值相等性，并且很少或没有任何行为。</span><span class="sxs-lookup"><span data-stu-id="7dc70-140">You can use [structure types](../language-reference/builtin-types/struct.md) to design data-centric types that provide value equality and little or no behavior.</span></span> <span data-ttu-id="7dc70-141">但对于相对较大的数据模型，结构类型有一些缺点：</span><span class="sxs-lookup"><span data-stu-id="7dc70-141">But for relatively large data models, structure types have some disadvantages:</span></span>

* <span data-ttu-id="7dc70-142">它们不支持继承。</span><span class="sxs-lookup"><span data-stu-id="7dc70-142">They don't support inheritance.</span></span>
* <span data-ttu-id="7dc70-143">它们在确定值相等性时效率较低。</span><span class="sxs-lookup"><span data-stu-id="7dc70-143">They're less efficient at determining value equality.</span></span> <span data-ttu-id="7dc70-144">对于值类型，<xref:System.ValueType.Equals%2A?displayProperty=nameWithType> 方法使用反射来查找所有字段。</span><span class="sxs-lookup"><span data-stu-id="7dc70-144">For value types, the <xref:System.ValueType.Equals%2A?displayProperty=nameWithType> method uses reflection to find all fields.</span></span> <span data-ttu-id="7dc70-145">对于记录，编译器将生成 `Equals` 方法。</span><span class="sxs-lookup"><span data-stu-id="7dc70-145">For records, the compiler generates the `Equals` method.</span></span> <span data-ttu-id="7dc70-146">实际上，记录中的值相等性实现的速度明显更快。</span><span class="sxs-lookup"><span data-stu-id="7dc70-146">In practice, the implementation of value equality in records is measurably faster.</span></span>
* <span data-ttu-id="7dc70-147">在某些情况下，它们会占用更多内存，因为每个实例都有所有数据的完整副本。</span><span class="sxs-lookup"><span data-stu-id="7dc70-147">They use more memory in some scenarios, since every instance has a complete copy of all of the data.</span></span> <span data-ttu-id="7dc70-148">记录类型是[引用类型](../language-reference/builtin-types/reference-types.md)，因此，记录实例只包含对数据的引用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-148">Record types are [reference types](../language-reference/builtin-types/reference-types.md), so a record instance contains only a reference to the data.</span></span>

### <a name="positional-syntax-for-property-definition"></a><span data-ttu-id="7dc70-149">属性定义的位置语法</span><span class="sxs-lookup"><span data-stu-id="7dc70-149">Positional syntax for property definition</span></span>

<span data-ttu-id="7dc70-150">在创建实例时，可以使用位置参数来声明记录的属性，并初始化属性值：</span><span class="sxs-lookup"><span data-stu-id="7dc70-150">You can use positional parameters to declare properties of a record and to initialize the property values when you create an instance:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InstantiatePositional":::

<span data-ttu-id="7dc70-151">当你为属性定义使用位置语法时，编译器将创建以下内容：</span><span class="sxs-lookup"><span data-stu-id="7dc70-151">When you use the positional syntax for property definition, the compiler creates:</span></span>

* <span data-ttu-id="7dc70-152">为记录声明中提供的每个位置参数提供一个公共的 init-only 自动实现的属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-152">A public init-only auto-implemented property for each positional parameter provided in the record declaration.</span></span> <span data-ttu-id="7dc70-153">[init-only](../language-reference/keywords/init.md) 属性只能在构造函数中或使用属性初始值设定项来设置。</span><span class="sxs-lookup"><span data-stu-id="7dc70-153">An [init-only](../language-reference/keywords/init.md) property can only be set in the constructor or by using a property initializer.</span></span>
* <span data-ttu-id="7dc70-154">主构造函数，它的参数与记录声明上的位置参数匹配。</span><span class="sxs-lookup"><span data-stu-id="7dc70-154">A primary constructor whose parameters match the positional parameters on the record declaration.</span></span>
* <span data-ttu-id="7dc70-155">一个 `Deconstruct` 方法，对记录声明中提供的每个位置参数都有一个 `out` 参数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-155">A `Deconstruct` method with an `out` parameter for each positional parameter provided in the record declaration.</span></span>

<span data-ttu-id="7dc70-156">有关详细信息，请参阅有关记录的 C# 语言参考文章中的[位置语法](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-156">For more information, see [Positional syntax](../language-reference/builtin-types/record.md#positional-syntax-for-property-definition) in the C# language reference article about records.</span></span>

### <a name="immutability"></a><span data-ttu-id="7dc70-157">不可变性</span><span class="sxs-lookup"><span data-stu-id="7dc70-157">Immutability</span></span>

<span data-ttu-id="7dc70-158">记录类型不一定是不可变的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-158">A record type is not necessarily immutable.</span></span> <span data-ttu-id="7dc70-159">可以用 `set` 访问器和非 `readonly` 的字段来声明属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-159">You can declare properties with `set` accessors and fields that aren't `readonly`.</span></span> <span data-ttu-id="7dc70-160">虽然记录可以是可变的，但它们使创建不可变的数据模型变得更容易。</span><span class="sxs-lookup"><span data-stu-id="7dc70-160">But while records can be mutable, they make it easier to create immutable data models.</span></span> <span data-ttu-id="7dc70-161">使用位置语法创建的属性是不可变的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-161">Properties that you create by using positional syntax are immutable.</span></span>

<span data-ttu-id="7dc70-162">如果希望以数据为中心的类型是线程安全的，或者哈希表中的哈希代码保持不变，那么不可变性很有用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-162">Immutability can be useful when you want a data-centric type to be thread-safe or a hash code to remain the same in a hash table.</span></span> <span data-ttu-id="7dc70-163">它可以防止在通过引用方法传递参数而该方法意外更改参数值时发生的 bug。</span><span class="sxs-lookup"><span data-stu-id="7dc70-163">It can prevent bugs that happen when you pass an argument by reference to a method, and the method unexpectedly changes the argument value.</span></span>

<span data-ttu-id="7dc70-164">记录类型特有的功能是由编译器合成的方法实现的，这些方法都不会通过修改对象状态来影响不可变性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-164">The features unique to record types are implemented by compiler-synthesized methods, and none of these methods compromises immutability by modifying object state.</span></span>

### <a name="value-equality"></a><span data-ttu-id="7dc70-165">值相等性</span><span class="sxs-lookup"><span data-stu-id="7dc70-165">Value equality</span></span>

<span data-ttu-id="7dc70-166">值相等性是指如果记录类型的两个变量类型相匹配，且所有属性和字段值都一致，那么记录类型的两个变量是相等的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-166">Value equality means that two variables of a record type are equal if the types match and all property and field values match.</span></span> <span data-ttu-id="7dc70-167">对于其他引用类型，相等是指标识。</span><span class="sxs-lookup"><span data-stu-id="7dc70-167">For other reference types, equality means identity.</span></span> <span data-ttu-id="7dc70-168">也就是说，如果一个引用类型的两个变量引用同一个对象，那么这两个变量是相等的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-168">That is, two variables of a reference type are equal if they refer to the same object.</span></span>

<span data-ttu-id="7dc70-169">下面的示例说明了记录类型的值相等性：</span><span class="sxs-lookup"><span data-stu-id="7dc70-169">The following example illustrates value equality of record types:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="Equality":::

<span data-ttu-id="7dc70-170">在 `class` 类型中，可以手动替代相等性方法和运算符以实现值相等性，但开发和测试这种代码会非常耗时，而且容易出错。</span><span class="sxs-lookup"><span data-stu-id="7dc70-170">In `class` types, you could manually override equality methods and operators to achieve value equality, but developing and testing that code would be time-consuming and error-prone.</span></span> <span data-ttu-id="7dc70-171">内置此功能可防止在添加或更改属性或字段时忘记更新自定义替代代码导致的 bug。</span><span class="sxs-lookup"><span data-stu-id="7dc70-171">Having this functionality built-in prevents bugs that would result from forgetting to update custom override code when properties or fields are added or changed.</span></span>

<span data-ttu-id="7dc70-172">有关详细信息，请参阅有关记录的 C# 语言参考文章中的[值相等性](../language-reference/builtin-types/record.md#value-equality)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-172">For more information, see [Value equality](../language-reference/builtin-types/record.md#value-equality) in the C# language reference article about records.</span></span>

### <a name="nondestructive-mutation"></a><span data-ttu-id="7dc70-173">非破坏性变化</span><span class="sxs-lookup"><span data-stu-id="7dc70-173">Nondestructive mutation</span></span>

<span data-ttu-id="7dc70-174">如果需要改变记录实例的不可变属性，可以使用 `with` 表达式来实现非破坏性变化。</span><span class="sxs-lookup"><span data-stu-id="7dc70-174">If you need to mutate immutable properties of a record instance, you can use a `with` expression to achieve *nondestructive mutation*.</span></span> <span data-ttu-id="7dc70-175">`with` 表达式创建一个新的记录实例，该实例是现有记录实例的一个副本，修改了指定属性和字段。</span><span class="sxs-lookup"><span data-stu-id="7dc70-175">A `with` expression makes a new record instance that is a copy of an existing record instance, with specified properties and fields modified.</span></span> <span data-ttu-id="7dc70-176">使用[对象初始值设定项](../programming-guide/classes-and-structs/object-and-collection-initializers.md)语法来指定要更改的值，如以下示例中所示：</span><span class="sxs-lookup"><span data-stu-id="7dc70-176">You use [object initializer](../programming-guide/classes-and-structs/object-and-collection-initializers.md) syntax to specify the values to be changed, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="WithExpressions":::

<span data-ttu-id="7dc70-177">有关详细信息，请参阅有关记录的 C# 语言参考文章中的[非破坏性变化](../language-reference/builtin-types/record.md#nondestructive-mutation)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-177">For more information, see [Nondestructive mutation](../language-reference/builtin-types/record.md#nondestructive-mutation) in the C# language reference article about records.</span></span>

### <a name="built-in-formatting-for-display"></a><span data-ttu-id="7dc70-178">用于显示的内置格式设置</span><span class="sxs-lookup"><span data-stu-id="7dc70-178">Built-in formatting for display</span></span>

<span data-ttu-id="7dc70-179">记录类型具有编译器生成的 <xref:System.Object.ToString%2A> 方法，可显示公共属性和字段的名称和值。</span><span class="sxs-lookup"><span data-stu-id="7dc70-179">Record types have a compiler-generated <xref:System.Object.ToString%2A> method that displays the names and values of public properties and fields.</span></span> <span data-ttu-id="7dc70-180">`ToString` 方法返回一个格式如下的字符串：</span><span class="sxs-lookup"><span data-stu-id="7dc70-180">The `ToString` method returns a string of the following format:</span></span>

> <span data-ttu-id="7dc70-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span><span class="sxs-lookup"><span data-stu-id="7dc70-181">\<record type name> { \<property name> = \<value>, \<property name> = \<value>, ...}</span></span>

<span data-ttu-id="7dc70-182">对于引用类型，将显示属性所引用的对象的类型名称，而不是属性值。</span><span class="sxs-lookup"><span data-stu-id="7dc70-182">For reference types, the type name of the object that the property refers to is displayed instead of the property value.</span></span> <span data-ttu-id="7dc70-183">在下面的示例中，数组是一个引用类型，因此显示的是 `System.String[]`，而不是实际的数组元素值：</span><span class="sxs-lookup"><span data-stu-id="7dc70-183">In the following example, the array is a reference type, so `System.String[]` is displayed instead of the actual array element values:</span></span>

```
Person { FirstName = Nancy, LastName = Davolio, ChildNames = System.String[] }
```

<span data-ttu-id="7dc70-184">有关详细信息，请参阅有关记录的 C# 语言参考文章中的[内置格式](../language-reference/builtin-types/record.md#built-in-formatting-for-display)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-184">For more information, see [Built-in formatting](../language-reference/builtin-types/record.md#built-in-formatting-for-display) in the C# language reference article about records.</span></span>

### <a name="inheritance"></a><span data-ttu-id="7dc70-185">继承</span><span class="sxs-lookup"><span data-stu-id="7dc70-185">Inheritance</span></span>

<span data-ttu-id="7dc70-186">一条记录可以从另一条记录继承。</span><span class="sxs-lookup"><span data-stu-id="7dc70-186">A record can inherit from another record.</span></span> <span data-ttu-id="7dc70-187">但是，记录不能从类继承，类也不能从记录继承。</span><span class="sxs-lookup"><span data-stu-id="7dc70-187">However, a record can't inherit from a class, and a class can't inherit from a record.</span></span>

<span data-ttu-id="7dc70-188">下面的示例说明了具有位置属性语法的继承：</span><span class="sxs-lookup"><span data-stu-id="7dc70-188">The following example illustrates inheritance with positional property syntax:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="PositionalInheritance":::

<span data-ttu-id="7dc70-189">要使两个记录变量相等，运行时类型必须相等。</span><span class="sxs-lookup"><span data-stu-id="7dc70-189">For two record variables to be equal, the run-time type must be equal.</span></span> <span data-ttu-id="7dc70-190">包含变量的类型可能不同。</span><span class="sxs-lookup"><span data-stu-id="7dc70-190">The types of the containing variables might be different.</span></span> <span data-ttu-id="7dc70-191">下面的代码示例中说明了这一点：</span><span class="sxs-lookup"><span data-stu-id="7dc70-191">This is illustrated in the following code example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="InheritanceEquality":::

<span data-ttu-id="7dc70-192">在本示例中，所有实例都具有相同的属性和相同的属性值。</span><span class="sxs-lookup"><span data-stu-id="7dc70-192">In the example, all instances have the same properties and the same property values.</span></span> <span data-ttu-id="7dc70-193">尽管两者都是 `Person` 类型变量，但 `student == teacher` 会返回 `False`。</span><span class="sxs-lookup"><span data-stu-id="7dc70-193">But `student == teacher` returns `False` although both are `Person`-type variables.</span></span> <span data-ttu-id="7dc70-194">尽管一个是 `Person` 变量，另一个是 `Student` 变量，但 `student == student2` 会返回 `True`。</span><span class="sxs-lookup"><span data-stu-id="7dc70-194">And `student == student2` returns `True` although one is a `Person` variable and one is a `Student` variable.</span></span>

<span data-ttu-id="7dc70-195">派生类型和基类型的所有公共属性和字段都包含在 `ToString` 输出中，如以下示例所示：</span><span class="sxs-lookup"><span data-stu-id="7dc70-195">All public properties and fields of both derived and base types are included in the `ToString` output, as shown in the following example:</span></span>

:::code language="csharp" source="../language-reference/builtin-types/snippets/shared/RecordType.cs" id="ToStringInheritance":::

<span data-ttu-id="7dc70-196">有关详细信息，请参阅有关记录的 C# 语言参考文章中的[继承](../language-reference/builtin-types/record.md#inheritance)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-196">For more information, see [Inheritance](../language-reference/builtin-types/record.md#inheritance) in the C# language reference article about records.</span></span>

## <a name="init-only-setters"></a><span data-ttu-id="7dc70-197">仅限 Init 的资源库</span><span class="sxs-lookup"><span data-stu-id="7dc70-197">Init only setters</span></span>

<span data-ttu-id="7dc70-198">仅限 init 的资源库提供一致的语法来初始化对象的成员。</span><span class="sxs-lookup"><span data-stu-id="7dc70-198">***Init only setters*** provide consistent syntax to initialize members of an object.</span></span> <span data-ttu-id="7dc70-199">属性初始值设定项可明确哪个值正在设置哪个属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-199">Property initializers make it clear which value is setting which property.</span></span> <span data-ttu-id="7dc70-200">缺点是这些属性必须是可设置的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-200">The downside is that those properties must be settable.</span></span> <span data-ttu-id="7dc70-201">从 C# 9.0 开始，可为属性和索引器创建 `init` 访问器，而不是 `set` 访问器。</span><span class="sxs-lookup"><span data-stu-id="7dc70-201">Starting with C# 9.0, you can create `init` accessors instead of `set` accessors for properties and indexers.</span></span> <span data-ttu-id="7dc70-202">调用方可使用属性初始化表达式语法在创建表达式中设置这些值，但构造完成后，这些属性将变为只读。</span><span class="sxs-lookup"><span data-stu-id="7dc70-202">Callers can use property initializer syntax to set these values in creation expressions, but those properties are readonly once construction has completed.</span></span> <span data-ttu-id="7dc70-203">仅限 init 的资源库提供了一个窗口用来更改状态。</span><span class="sxs-lookup"><span data-stu-id="7dc70-203">Init only setters provide a window to change state.</span></span> <span data-ttu-id="7dc70-204">构造阶段结束时，该窗口关闭。</span><span class="sxs-lookup"><span data-stu-id="7dc70-204">That window closes when the construction phase ends.</span></span> <span data-ttu-id="7dc70-205">在完成所有初始化（包括属性初始化表达式和 with 表达式）之后，构造阶段实际上就结束了。</span><span class="sxs-lookup"><span data-stu-id="7dc70-205">The construction phase effectively ends after all initialization, including property initializers and with-expressions have completed.</span></span>

<span data-ttu-id="7dc70-206">可在编写的任何类型中声明仅限 `init` 的资源库。</span><span class="sxs-lookup"><span data-stu-id="7dc70-206">You can declare `init` only setters in any type you write.</span></span> <span data-ttu-id="7dc70-207">例如，以下结构定义了天气观察结构：</span><span class="sxs-lookup"><span data-stu-id="7dc70-207">For example, the following struct defines a weather observation structure:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="DeclareWeatherObservation":::

<span data-ttu-id="7dc70-208">调用方可使用属性初始化表达式语法来设置值，同时仍保留不变性：</span><span class="sxs-lookup"><span data-stu-id="7dc70-208">Callers can use property initializer syntax to set the values, while still preserving the immutability:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/WeatherObservation.cs" ID="UseWeatherObservation":::

<span data-ttu-id="7dc70-209">初始化后尝试更改观察值会导致编译器错误：</span><span class="sxs-lookup"><span data-stu-id="7dc70-209">An attempt to change an observation after initialization results in a compiler error:</span></span>

```csharp
// Error! CS8852.
now.TemperatureInCelsius = 18;
```

<span data-ttu-id="7dc70-210">对于从派生类设置基类属性，仅限 init 的资源库很有用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-210">Init only setters can be useful to set base class properties from derived classes.</span></span> <span data-ttu-id="7dc70-211">它们还可通过基类中的帮助程序来设置派生属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-211">They can also set derived properties through helpers in a base class.</span></span> <span data-ttu-id="7dc70-212">位置记录使用仅限 init 的资源库声明属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-212">Positional records declare properties using init only setters.</span></span> <span data-ttu-id="7dc70-213">这些设置器可在 with 表达式中使用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-213">Those setters are used in with-expressions.</span></span> <span data-ttu-id="7dc70-214">可为定义的任何 `class`、`struct` 或 `record` 声明仅限 init 的资源库。</span><span class="sxs-lookup"><span data-stu-id="7dc70-214">You can declare init only setters for any `class`, `struct`, or `record` you define.</span></span>

<span data-ttu-id="7dc70-215">有关详细信息，请查看 [init（C# 参考）](../language-reference/keywords/init.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-215">For more information, see [init (C# Reference)](../language-reference/keywords/init.md).</span></span>

## <a name="top-level-statements"></a><span data-ttu-id="7dc70-216">顶级语句</span><span class="sxs-lookup"><span data-stu-id="7dc70-216">Top-level statements</span></span>

<span data-ttu-id="7dc70-217">顶级语句从许多应用程序中删除了不必要的流程。</span><span class="sxs-lookup"><span data-stu-id="7dc70-217">***Top-level statements*** remove unnecessary ceremony from many applications.</span></span> <span data-ttu-id="7dc70-218">请考虑规范的“Hello World!”</span><span class="sxs-lookup"><span data-stu-id="7dc70-218">Consider the canonical "Hello World!"</span></span> <span data-ttu-id="7dc70-219">程序：</span><span class="sxs-lookup"><span data-stu-id="7dc70-219">program:</span></span>

```csharp
using System;

namespace HelloWorld
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello World!");
        }
    }
}
```

<span data-ttu-id="7dc70-220">只有一行代码执行所有操作。</span><span class="sxs-lookup"><span data-stu-id="7dc70-220">There's only one line of code that does anything.</span></span> <span data-ttu-id="7dc70-221">借助顶级语句，可使用 `using` 指令和执行操作的一行替换所有样本：</span><span class="sxs-lookup"><span data-stu-id="7dc70-221">With top-level statements, you can replace all that boilerplate with the `using` directive and the single line that does the work:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/Program.cs" ID="TopLevelStatements":::

<span data-ttu-id="7dc70-222">如果需要单行程序，可删除 `using` 指令，并使用完全限定的类型名称：</span><span class="sxs-lookup"><span data-stu-id="7dc70-222">If you wanted a one-line program, you could remove the `using` directive and use the fully qualified type name:</span></span>

```csharp
System.Console.WriteLine("Hello World!");
```

<span data-ttu-id="7dc70-223">应用程序中只有一个文件可使用顶级语句。</span><span class="sxs-lookup"><span data-stu-id="7dc70-223">Only one file in your application may use top-level statements.</span></span> <span data-ttu-id="7dc70-224">如果编译器在多个源文件中找到顶级语句，则是错误的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-224">If the compiler finds top-level statements in multiple source files, it's an error.</span></span> <span data-ttu-id="7dc70-225">如果将顶级语句与声明的程序入口点方法（通常为 `Main` 方法）结合使用，也会出现错误。</span><span class="sxs-lookup"><span data-stu-id="7dc70-225">It's also an error if you combine top-level statements with a declared program entry point method, typically a `Main` method.</span></span> <span data-ttu-id="7dc70-226">从某种意义上讲，可认为一个文件包含通常位于 `Program` 类的 `Main` 方法中的语句。</span><span class="sxs-lookup"><span data-stu-id="7dc70-226">In a sense, you can think that one file contains the statements that would normally be in the `Main` method of a `Program` class.</span></span>  

<span data-ttu-id="7dc70-227">此功能最常见的用途之一是创建材料。</span><span class="sxs-lookup"><span data-stu-id="7dc70-227">One of the most common uses for this feature is creating teaching materials.</span></span> <span data-ttu-id="7dc70-228">C# 初级开发人员可以用一两行代码</span><span class="sxs-lookup"><span data-stu-id="7dc70-228">Beginner C# developers can write the canonical "Hello World!"</span></span> <span data-ttu-id="7dc70-229">编写规范的“Hello World!”。</span><span class="sxs-lookup"><span data-stu-id="7dc70-229">in one or two lines of code.</span></span> <span data-ttu-id="7dc70-230">不需要额外的工作。</span><span class="sxs-lookup"><span data-stu-id="7dc70-230">None of the extra ceremony is needed.</span></span> <span data-ttu-id="7dc70-231">不过，经验丰富的开发人员还会发现此功能的许多用途。</span><span class="sxs-lookup"><span data-stu-id="7dc70-231">However, seasoned developers will find many uses for this feature as well.</span></span> <span data-ttu-id="7dc70-232">顶级语句可提供类似脚本的试验体验，这与 Jupyter 笔记本提供的很类似。</span><span class="sxs-lookup"><span data-stu-id="7dc70-232">Top-level statements enable a script-like experience for experimentation similar to what Jupyter notebooks provide.</span></span> <span data-ttu-id="7dc70-233">顶级语句非常适合小型控制台程序和实用程序。</span><span class="sxs-lookup"><span data-stu-id="7dc70-233">Top-level statements are great for small console programs and utilities.</span></span> <span data-ttu-id="7dc70-234">[Azure Functions](/azure/azure-functions/) 是顶级语句的理想用例。</span><span class="sxs-lookup"><span data-stu-id="7dc70-234">[Azure Functions](/azure/azure-functions/) is an ideal use case for top-level statements.</span></span>

<span data-ttu-id="7dc70-235">最重要的是，顶层语句不会限制应用程序的范围或复杂程度。</span><span class="sxs-lookup"><span data-stu-id="7dc70-235">Most importantly, top-level statements don't limit your application's scope or complexity.</span></span> <span data-ttu-id="7dc70-236">这些语句可访问或使用任何 .NET 类。</span><span class="sxs-lookup"><span data-stu-id="7dc70-236">Those statements can access or use any .NET class.</span></span> <span data-ttu-id="7dc70-237">它们也不会限制你对命令行参数或返回值的使用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-237">They also don't limit your use of command-line arguments or return values.</span></span> <span data-ttu-id="7dc70-238">顶级语句可访问名为 `args` 的字符串数组。</span><span class="sxs-lookup"><span data-stu-id="7dc70-238">Top-level statements can access an array of strings named `args`.</span></span> <span data-ttu-id="7dc70-239">如果顶级语句返回整数值，则该值将成为来自合成 `Main` 方法的整数返回代码。</span><span class="sxs-lookup"><span data-stu-id="7dc70-239">If the top-level statements return an integer value, that value becomes the integer return code from a synthesized `Main` method.</span></span> <span data-ttu-id="7dc70-240">顶级语句可能包含异步表达式。</span><span class="sxs-lookup"><span data-stu-id="7dc70-240">The top-level statements may contain async expressions.</span></span> <span data-ttu-id="7dc70-241">在这种情况下，合成入口点将返回 `Task` 或 `Task<int>`。</span><span class="sxs-lookup"><span data-stu-id="7dc70-241">In that case, the synthesized entry point returns a `Task`, or `Task<int>`.</span></span>

<span data-ttu-id="7dc70-242">有关详细信息，请参阅 C# 编程指南中的[顶级语句](../programming-guide/main-and-command-args/top-level-statements.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-242">For more information, see [Top-level statements](../programming-guide/main-and-command-args/top-level-statements.md) in the C# Programming Guide.</span></span>

## <a name="pattern-matching-enhancements"></a><span data-ttu-id="7dc70-243">模式匹配增强功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-243">Pattern matching enhancements</span></span>

<span data-ttu-id="7dc70-244">C# 9 包括新的模式匹配改进：</span><span class="sxs-lookup"><span data-stu-id="7dc70-244">C# 9 includes new pattern matching improvements:</span></span>

- <span data-ttu-id="7dc70-245">类型模式要求在变量是一种类型时匹配</span><span class="sxs-lookup"><span data-stu-id="7dc70-245">***Type patterns*** match a variable is a type</span></span>
- <span data-ttu-id="7dc70-246">带圆括号的模式强制或强调模式组合的优先级</span><span class="sxs-lookup"><span data-stu-id="7dc70-246">***Parenthesized patterns*** enforce or emphasize the precedence of pattern combinations</span></span>
- <span data-ttu-id="7dc70-247">联合 `and` 模式要求两个模式都匹配</span><span class="sxs-lookup"><span data-stu-id="7dc70-247">***Conjunctive `and` patterns*** require both patterns to match</span></span>
- <span data-ttu-id="7dc70-248">析取 `or` 模式要求任一模式匹配</span><span class="sxs-lookup"><span data-stu-id="7dc70-248">***Disjunctive `or` patterns*** require either pattern to match</span></span>
- <span data-ttu-id="7dc70-249">否定 `not` 模式要求模式不匹配</span><span class="sxs-lookup"><span data-stu-id="7dc70-249">***Negated `not` patterns*** require that a pattern doesn't match</span></span>
- <span data-ttu-id="7dc70-250">关系模式要求输入小于、大于、小于等于或大于等于给定常数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-250">***Relational patterns*** require the input be less than, greater than, less than or equal, or greater than or equal to a given constant.</span></span>

<span data-ttu-id="7dc70-251">这些模式丰富了模式的语法。</span><span class="sxs-lookup"><span data-stu-id="7dc70-251">These patterns enrich the syntax for patterns.</span></span> <span data-ttu-id="7dc70-252">请考虑下列示例：</span><span class="sxs-lookup"><span data-stu-id="7dc70-252">Consider these examples:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterPattern":::

<span data-ttu-id="7dc70-253">使用可选的括号来明确 `and` 的优先级高于 `or`：</span><span class="sxs-lookup"><span data-stu-id="7dc70-253">With optional parentheses to make it clear that `and` has higher precedence than `or`:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/PatternUtilities.cs" ID="IsLetterOrSeparatorPattern":::

<span data-ttu-id="7dc70-254">最常见的用途之一是用于 NULL 检查的新语法：</span><span class="sxs-lookup"><span data-stu-id="7dc70-254">One of the most common uses is a new syntax for a null check:</span></span>

```csharp
if (e is not null)
{
    // ...
}
```

<span data-ttu-id="7dc70-255">后面模式中的任何一种都可在允许使用模式的任何上下文中使用：`is` 模式表达式、`switch` 表达式、嵌套模式以及 `switch` 语句的 `case` 标签的模式。</span><span class="sxs-lookup"><span data-stu-id="7dc70-255">Any of these patterns can be used in any context where patterns are allowed: `is` pattern expressions, `switch` expressions, nested patterns, and the pattern of a `switch` statement's `case` label.</span></span>

<span data-ttu-id="7dc70-256">有关详细信息，请查看[模式（C# 参考）](../language-reference/operators/patterns.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-256">For more information, see [Patterns (C# reference)](../language-reference/operators/patterns.md).</span></span>

<span data-ttu-id="7dc70-257">有关详细信息，请参阅[模式](../language-reference/operators/patterns.md)一文中的[关系模式](../language-reference/operators/patterns.md#relational-patterns)和[逻辑模式](../language-reference/operators/patterns.md#logical-patterns)部分。</span><span class="sxs-lookup"><span data-stu-id="7dc70-257">For more information, see the [Relational patterns](../language-reference/operators/patterns.md#relational-patterns) and [Logical patterns](../language-reference/operators/patterns.md#logical-patterns) sections of the [Patterns](../language-reference/operators/patterns.md) article.</span></span>

## <a name="performance-and-interop"></a><span data-ttu-id="7dc70-258">性能和互操作性</span><span class="sxs-lookup"><span data-stu-id="7dc70-258">Performance and interop</span></span>

<span data-ttu-id="7dc70-259">3 项新功能改进了对需要高性能的本机互操作性和低级别库的支持：本机大小的整数、函数指针和省略 `localsinit` 标志。</span><span class="sxs-lookup"><span data-stu-id="7dc70-259">Three new features improve support for native interop and low-level libraries that require high performance: native sized integers, function pointers, and omitting the `localsinit` flag.</span></span>

<span data-ttu-id="7dc70-260">本机大小的整数 `nint` 和 `nuint` 是整数类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-260">Native sized integers, `nint` and `nuint`, are integer types.</span></span> <span data-ttu-id="7dc70-261">它们由基础类型 <xref:System.IntPtr?displayProperty=nameWithType> 和 <xref:System.UIntPtr?displayProperty=nameWithType> 表示。</span><span class="sxs-lookup"><span data-stu-id="7dc70-261">They're expressed by the underlying types <xref:System.IntPtr?displayProperty=nameWithType> and <xref:System.UIntPtr?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7dc70-262">编译器将这些类型的其他转换和操作作为本机整数公开。</span><span class="sxs-lookup"><span data-stu-id="7dc70-262">The compiler surfaces additional conversions and operations for these types as native ints.</span></span> <span data-ttu-id="7dc70-263">本机大小的整数定义 `MaxValue` 或 `MinValue` 的属性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-263">Native sized integers define properties for `MaxValue` or `MinValue`.</span></span> <span data-ttu-id="7dc70-264">这些值不能表示为编译时编译时，因为它们取决于目标计算机上整数的本机大小。</span><span class="sxs-lookup"><span data-stu-id="7dc70-264">These values can't be expressed as compile-time constants because they depend on the native size of an integer on the target machine.</span></span> <span data-ttu-id="7dc70-265">这些值在运行时是只读的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-265">Those values are readonly at runtime.</span></span> <span data-ttu-id="7dc70-266">可在以下范围内对 `nint` 使用常量值：[`int.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="7dc70-266">You can use constant values for `nint` in the range [`int.MinValue` ..</span></span> <span data-ttu-id="7dc70-267">`int.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="7dc70-267">`int.MaxValue`].</span></span> <span data-ttu-id="7dc70-268">可在以下范围内对 `nuint` 使用常量值：[`uint.MinValue` ..</span><span class="sxs-lookup"><span data-stu-id="7dc70-268">You can use constant values for `nuint` in the range [`uint.MinValue` ..</span></span> <span data-ttu-id="7dc70-269">`uint.MaxValue`].</span><span class="sxs-lookup"><span data-stu-id="7dc70-269">`uint.MaxValue`].</span></span> <span data-ttu-id="7dc70-270">编译器使用 <xref:System.Int32?displayProperty=nameWithType> 和 <xref:System.UInt32?displayProperty=nameWithType> 类型为所有一元和二元运算符执行常量折叠。</span><span class="sxs-lookup"><span data-stu-id="7dc70-270">The compiler performs constant folding for all unary and binary operators using the <xref:System.Int32?displayProperty=nameWithType> and <xref:System.UInt32?displayProperty=nameWithType> types.</span></span> <span data-ttu-id="7dc70-271">如果结果不满足 32 位，操作将在运行时执行，且不会被视为常量。</span><span class="sxs-lookup"><span data-stu-id="7dc70-271">If the result doesn't fit in 32 bits, the operation is executed at runtime and isn't considered a constant.</span></span> <span data-ttu-id="7dc70-272">在广泛使用整数数学且需要尽可能快的性能的情况下，本机大小的整数可提高性能。</span><span class="sxs-lookup"><span data-stu-id="7dc70-272">Native sized integers can increase performance in scenarios where integer math is used extensively and needs to have the fastest performance possible.</span></span> <span data-ttu-id="7dc70-273">有关详细信息，请参阅 [`nint` 和 `nuint` 类型](../language-reference/builtin-types/nint-nuint.md)</span><span class="sxs-lookup"><span data-stu-id="7dc70-273">For more information, see [`nint` and `nuint` types](../language-reference/builtin-types/nint-nuint.md)</span></span>

<span data-ttu-id="7dc70-274">函数指针提供了一种简单的语法来访问 IL 操作码 `ldftn` 和 `calli`。</span><span class="sxs-lookup"><span data-stu-id="7dc70-274">Function pointers provide an easy syntax to access the IL opcodes `ldftn` and `calli`.</span></span> <span data-ttu-id="7dc70-275">可使用新的 `delegate*` 语法声明函数指针。</span><span class="sxs-lookup"><span data-stu-id="7dc70-275">You can declare function pointers using new `delegate*` syntax.</span></span> <span data-ttu-id="7dc70-276">`delegate*` 类型是指针类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-276">A `delegate*` type is a pointer type.</span></span> <span data-ttu-id="7dc70-277">调用 `delegate*` 类型会使用 `calli`，而不是使用在 `Invoke()` 方法上采用 `callvirt` 的委托。</span><span class="sxs-lookup"><span data-stu-id="7dc70-277">Invoking the `delegate*` type uses `calli`, in contrast to a delegate that uses `callvirt` on the `Invoke()` method.</span></span> <span data-ttu-id="7dc70-278">从语法上讲，调用是相同的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-278">Syntactically, the invocations are identical.</span></span> <span data-ttu-id="7dc70-279">函数指针调用使用 `managed` 调用约定。</span><span class="sxs-lookup"><span data-stu-id="7dc70-279">Function pointer invocation uses the `managed` calling convention.</span></span> <span data-ttu-id="7dc70-280">在 `delegate*` 语法后面添加 `unmanaged` 关键字，以声明想要 `unmanaged` 调用约定。</span><span class="sxs-lookup"><span data-stu-id="7dc70-280">You add the `unmanaged` keyword after the `delegate*` syntax to declare that you want the `unmanaged` calling convention.</span></span> <span data-ttu-id="7dc70-281">可使用 `delegate*` 声明中的属性来指定其他调用约定。</span><span class="sxs-lookup"><span data-stu-id="7dc70-281">Other calling conventions can be specified using attributes on the `delegate*` declaration.</span></span> <span data-ttu-id="7dc70-282">有关详细信息，请参阅[不安全代码和指针类型](../language-reference/unsafe-code.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-282">For more information, see [Unsafe code and pointer types](../language-reference/unsafe-code.md).</span></span>

<span data-ttu-id="7dc70-283">最后，可添加 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> 来指示编译器不要发出 `localsinit` 标志。</span><span class="sxs-lookup"><span data-stu-id="7dc70-283">Finally, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute?displayProperty=nameWithType> to instruct the compiler not to emit the `localsinit` flag.</span></span> <span data-ttu-id="7dc70-284">此标志指示 CLR 对所有局部变量进行零初始化。</span><span class="sxs-lookup"><span data-stu-id="7dc70-284">This flag instructs the CLR to zero-initialize all local variables.</span></span> <span data-ttu-id="7dc70-285">从 1.0 开始，`localsinit` 标志一直是 C# 的默认行为。</span><span class="sxs-lookup"><span data-stu-id="7dc70-285">The `localsinit` flag has been the default behavior for C# since 1.0.</span></span> <span data-ttu-id="7dc70-286">但在某些情况下，额外的零初始化可能会对性能产生可衡量的影响，</span><span class="sxs-lookup"><span data-stu-id="7dc70-286">However, the extra zero-initialization may have measurable performance impact in some scenarios.</span></span> <span data-ttu-id="7dc70-287">特别是在使用 `stackalloc` 时。</span><span class="sxs-lookup"><span data-stu-id="7dc70-287">In particular, when you use `stackalloc`.</span></span> <span data-ttu-id="7dc70-288">在这些情况下，可添加 <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>。</span><span class="sxs-lookup"><span data-stu-id="7dc70-288">In those cases, you can add the <xref:System.Runtime.CompilerServices.SkipLocalsInitAttribute>.</span></span> <span data-ttu-id="7dc70-289">可将它添加到单个方法或属性中，或者添加到 `class`、`struct`、`interface`，甚至是模块中。</span><span class="sxs-lookup"><span data-stu-id="7dc70-289">You may add it to a single method or property, or to a `class`, `struct`, `interface`, or even a module.</span></span> <span data-ttu-id="7dc70-290">此属性不会影响 `abstract` 方法，它会影响为实现生成的代码。</span><span class="sxs-lookup"><span data-stu-id="7dc70-290">This attribute doesn't affect `abstract` methods; it affects the code generated for the implementation.</span></span> <span data-ttu-id="7dc70-291">有关详细信息，请参阅 [`SkipLocalsInit` 属性](../language-reference/attributes/general.md#skiplocalsinit-attribute)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-291">For more information, see [`SkipLocalsInit` attribute](../language-reference/attributes/general.md#skiplocalsinit-attribute).</span></span>

<span data-ttu-id="7dc70-292">这些功能在某些情况下可提高性能。</span><span class="sxs-lookup"><span data-stu-id="7dc70-292">These features can improve performance in some scenarios.</span></span> <span data-ttu-id="7dc70-293">仅应在采用前后对这些功能进行仔细的基准测试之后使用它们。</span><span class="sxs-lookup"><span data-stu-id="7dc70-293">They should be used only after careful benchmarking both before and after adoption.</span></span> <span data-ttu-id="7dc70-294">涉及本机大小整数的代码必须在使用不同整数大小的多个目标平台上进行测试。</span><span class="sxs-lookup"><span data-stu-id="7dc70-294">Code involving native sized integers must be tested on multiple target platforms with different integer sizes.</span></span> <span data-ttu-id="7dc70-295">其他功能需要不安全的代码。</span><span class="sxs-lookup"><span data-stu-id="7dc70-295">The other features require unsafe code.</span></span>

## <a name="fit-and-finish-features"></a><span data-ttu-id="7dc70-296">调整和完成功能</span><span class="sxs-lookup"><span data-stu-id="7dc70-296">Fit and finish features</span></span>

<span data-ttu-id="7dc70-297">还有其他很多功能有助于更高效地编写代码。</span><span class="sxs-lookup"><span data-stu-id="7dc70-297">Many of the other features help you write code more efficiently.</span></span> <span data-ttu-id="7dc70-298">在 C# 9.0 中，已知创建对象的类型时，可在 [`new`](../language-reference/operators/new-operator.md) 表达式中省略该类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-298">In C# 9.0, you can omit the type in a [`new` expression](../language-reference/operators/new-operator.md) when the created object's type is already known.</span></span> <span data-ttu-id="7dc70-299">最常见的用法是在字段声明中：</span><span class="sxs-lookup"><span data-stu-id="7dc70-299">The most common use is in field declarations:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="WeatherStationField":::

<span data-ttu-id="7dc70-300">当需要创建新对象作为参数传递给方法时，也可使用目标类型 `new`。</span><span class="sxs-lookup"><span data-stu-id="7dc70-300">Target-typed `new` can also be used when you need to create a new object to pass as an argument to a method.</span></span> <span data-ttu-id="7dc70-301">请考虑使用以下签名的 `ForecastFor()` 方法：</span><span class="sxs-lookup"><span data-stu-id="7dc70-301">Consider a `ForecastFor()` method with the following signature:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="ForecastSignature":::

<span data-ttu-id="7dc70-302">可按如下所示调用该方法：</span><span class="sxs-lookup"><span data-stu-id="7dc70-302">You could call it as follows:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="TargetTypeNewArgument":::

<span data-ttu-id="7dc70-303">此功能还有一个不错的用途是，将其与仅限 init 的属性组合使用来初始化新对象：</span><span class="sxs-lookup"><span data-stu-id="7dc70-303">Another nice use for this feature is to combine it with init only properties to initialize a new object:</span></span>

:::code language="csharp" source="snippets/whats-new-csharp9/FitAndFinish.cs" ID="InitWeatherStation":::

<span data-ttu-id="7dc70-304">可使用 `return new();` 语句返回由默认构造函数创建的实例。</span><span class="sxs-lookup"><span data-stu-id="7dc70-304">You can return an instance created by the default constructor using a `return new();` statement.</span></span>

<span data-ttu-id="7dc70-305">类似的功能可改进[条件表达式](../language-reference/operators/conditional-operator.md)的目标类型解析。</span><span class="sxs-lookup"><span data-stu-id="7dc70-305">A similar feature improves the target type resolution of [conditional expressions](../language-reference/operators/conditional-operator.md).</span></span> <span data-ttu-id="7dc70-306">进行此更改后，两个表达式无需从一个隐式转换到另一个，而是都可隐式转换为目标类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-306">With this change, the two expressions need not have an implicit conversion from one to the other, but may both have implicit conversions to a target type.</span></span> <span data-ttu-id="7dc70-307">你可能不会注意到此更改。</span><span class="sxs-lookup"><span data-stu-id="7dc70-307">You likely won't notice this change.</span></span> <span data-ttu-id="7dc70-308">你会注意到，某些以前需要强制转换或无法编译的条件表达式现在可以正常工作。</span><span class="sxs-lookup"><span data-stu-id="7dc70-308">What you will notice is that some conditional expressions that previously required casts or wouldn't compile now just work.</span></span>

<span data-ttu-id="7dc70-309">从 C# 9.0 开始，可将 `static` 修饰符添加到 [Lambda 表达式](../language-reference/operators/lambda-expressions.md)或[匿名方法](../language-reference/operators/delegate-operator.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-309">Starting in C# 9.0, you can add the `static` modifier to [lambda expressions](../language-reference/operators/lambda-expressions.md) or [anonymous methods](../language-reference/operators/delegate-operator.md).</span></span> <span data-ttu-id="7dc70-310">静态 Lambda 表达式类似于 `static` 局部函数：静态 Lambda 或匿名方法无法捕获局部变量或实例状态。</span><span class="sxs-lookup"><span data-stu-id="7dc70-310">Static lambda expressions are analogous to the `static` local functions: a static lambda or anonymous method can't capture local variables or instance state.</span></span> <span data-ttu-id="7dc70-311">`static` 修饰符可防止意外捕获其他变量。</span><span class="sxs-lookup"><span data-stu-id="7dc70-311">The `static` modifier prevents accidentally capturing other variables.</span></span>

<span data-ttu-id="7dc70-312">协变返回类型为[重写](../language-reference/keywords/override.md)方法的返回类型提供了灵活性。</span><span class="sxs-lookup"><span data-stu-id="7dc70-312">Covariant return types provide flexibility for the return types of [override](../language-reference/keywords/override.md) methods.</span></span> <span data-ttu-id="7dc70-313">重写方法可返回从重写基方法的返回类型派生的类型。</span><span class="sxs-lookup"><span data-stu-id="7dc70-313">An override method can return a type derived from the return type of the overridden base method.</span></span> <span data-ttu-id="7dc70-314">这对于记录和其他支持虚拟克隆或工厂方法的类型很有用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-314">This can be useful for records and for other types that support virtual clone or factory methods.</span></span>

<span data-ttu-id="7dc70-315">此外，[`foreach` 循环](../language-reference/keywords/foreach-in.md)将识别并使用扩展方法 `GetEnumerator`，否则将满足 `foreach` 模式。</span><span class="sxs-lookup"><span data-stu-id="7dc70-315">In addition, the [`foreach` loop](../language-reference/keywords/foreach-in.md) will recognize and use an extension method `GetEnumerator` that otherwise satisfies the `foreach` pattern.</span></span> <span data-ttu-id="7dc70-316">此更改意味着 `foreach` 与其他基于模式的构造（例如异步模式和基于模式的析构）一致。</span><span class="sxs-lookup"><span data-stu-id="7dc70-316">This change means `foreach` is consistent with other pattern-based constructions such as the async pattern, and pattern-based deconstruction.</span></span> <span data-ttu-id="7dc70-317">实际上，此更改意味着可以为任何类型添加 `foreach` 支持。</span><span class="sxs-lookup"><span data-stu-id="7dc70-317">In practice, this change means you can add `foreach` support to any type.</span></span> <span data-ttu-id="7dc70-318">在设计中，应将其限制为在枚举对象有意义时使用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-318">You should limit its use to when enumerating an object makes sense in your design.</span></span>

<span data-ttu-id="7dc70-319">接下来，可使用弃元作为 Lambda 表达式的参数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-319">Next, you can use discards as parameters to lambda expressions.</span></span> <span data-ttu-id="7dc70-320">这样可免于为参数命名，并且编译器也可避免使用它。</span><span class="sxs-lookup"><span data-stu-id="7dc70-320">This convenience enables you to avoid naming the argument, and the compiler may avoid using it.</span></span> <span data-ttu-id="7dc70-321">可将 `_` 用于任何参数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-321">You use the `_` for any argument.</span></span> <span data-ttu-id="7dc70-322">有关详细信息，请参阅 [Lambda 表达式](../language-reference/operators/lambda-expressions.md)一文中的 [Lambda 表达式的输入参数](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression)一节。</span><span class="sxs-lookup"><span data-stu-id="7dc70-322">For more information, see the [Input parameters of a lambda expression](../language-reference/operators/lambda-expressions.md#input-parameters-of-a-lambda-expression) section of the [Lambda expressions](../language-reference/operators/lambda-expressions.md) article.</span></span>

<span data-ttu-id="7dc70-323">最后，现在可将属性应用于[本地函数](../programming-guide/classes-and-structs/local-functions.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-323">Finally, you can now apply attributes to [local functions](../programming-guide/classes-and-structs/local-functions.md).</span></span> <span data-ttu-id="7dc70-324">例如，可将[可为空的属性注释](../language-reference/attributes/nullable-analysis.md)应用于本地函数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-324">For example, you can apply [nullable attribute annotations](../language-reference/attributes/nullable-analysis.md) to local functions.</span></span>

## <a name="support-for-code-generators"></a><span data-ttu-id="7dc70-325">支持代码生成器</span><span class="sxs-lookup"><span data-stu-id="7dc70-325">Support for code generators</span></span>

<span data-ttu-id="7dc70-326">最后两项功能支持 C# 代码生成器。</span><span class="sxs-lookup"><span data-stu-id="7dc70-326">Two final features support C# code generators.</span></span> <span data-ttu-id="7dc70-327">C# 代码生成器是可编写的组件，类似于 roslyn 分析器或代码修补程序。</span><span class="sxs-lookup"><span data-stu-id="7dc70-327">C# code generators are a component you can write that is similar to a roslyn analyzer or code fix.</span></span> <span data-ttu-id="7dc70-328">区别在于，代码生成器会在编译过程中分析代码并编写新的源代码文件。</span><span class="sxs-lookup"><span data-stu-id="7dc70-328">The difference is that code generators analyze code and write new source code files as part of the compilation process.</span></span> <span data-ttu-id="7dc70-329">典型的代码生成器会在代码中搜索属性或其他约定。</span><span class="sxs-lookup"><span data-stu-id="7dc70-329">A typical code generator searches code for attributes or other conventions.</span></span>

<span data-ttu-id="7dc70-330">代码生成器使用 Roslyn 分析 API 读取属性或其他代码元素。</span><span class="sxs-lookup"><span data-stu-id="7dc70-330">A code generator reads attributes or other code elements using the Roslyn analysis APIs.</span></span> <span data-ttu-id="7dc70-331">通过该信息，它将新代码添加到编译中。</span><span class="sxs-lookup"><span data-stu-id="7dc70-331">From that information, it adds new code to the compilation.</span></span> <span data-ttu-id="7dc70-332">源生成器只能添加代码，不能修改编译中的任何现有代码。</span><span class="sxs-lookup"><span data-stu-id="7dc70-332">Source generators can only add code; they aren't allowed to modify any existing code in the compilation.</span></span>

<span data-ttu-id="7dc70-333">为代码生成器添加的两项功能是“分部方法语法”和“模块初始化表达式”的扩展。</span><span class="sxs-lookup"><span data-stu-id="7dc70-333">The two features added for code generators are extensions to ***partial method syntax** _, and _*_module initializers_\*\*.</span></span> <span data-ttu-id="7dc70-334">首先是对分部方法的更改。</span><span class="sxs-lookup"><span data-stu-id="7dc70-334">First, the changes to partial methods.</span></span> <span data-ttu-id="7dc70-335">在 C# 9.0 之前，分部方法为 `private`，但不能指定访问修饰符、不能返回 `void`，也不能具有 `out` 参数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-335">Before C# 9.0, partial methods are `private` but can't specify an access modifier, have a `void` return, and can't have `out` parameters.</span></span> <span data-ttu-id="7dc70-336">这些限制意味着，如果未提供任何方法实现，编译器会删除对分部方法的所有调用。</span><span class="sxs-lookup"><span data-stu-id="7dc70-336">These restrictions meant that if no method implementation is provided, the compiler removes all calls to the partial method.</span></span> <span data-ttu-id="7dc70-337">C# 9.0 消除了这些限制，但要求分部方法声明必须具有实现。</span><span class="sxs-lookup"><span data-stu-id="7dc70-337">C# 9.0 removes these restrictions, but requires that partial method declarations have an implementation.</span></span> <span data-ttu-id="7dc70-338">代码生成器可提供这种实现。</span><span class="sxs-lookup"><span data-stu-id="7dc70-338">Code generators can provide that implementation.</span></span> <span data-ttu-id="7dc70-339">为了避免引入中断性变更，编译器会考虑没有访问修饰符的任何分部方法，以遵循旧规则。</span><span class="sxs-lookup"><span data-stu-id="7dc70-339">To avoid introducing a breaking change, the compiler considers any partial method without an access modifier to follow the old rules.</span></span> <span data-ttu-id="7dc70-340">如果分部方法包括 `private` 访问修饰符，则由新规则控制该分部方法。</span><span class="sxs-lookup"><span data-stu-id="7dc70-340">If the partial method includes the `private` access modifier, the new rules govern that partial method.</span></span> <span data-ttu-id="7dc70-341">有关详细信息，请查看[分部方法（C# 参考）](../language-reference/keywords/partial-method.md)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-341">For more information, see [partial method (C# Reference)](../language-reference/keywords/partial-method.md).</span></span>

<span data-ttu-id="7dc70-342">代码生成器的第二项新功能是模块初始化表达式。</span><span class="sxs-lookup"><span data-stu-id="7dc70-342">The second new feature for code generators is ***module initializers***.</span></span> <span data-ttu-id="7dc70-343">模块初始化表达式是附加了 <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> 属性的方法。</span><span class="sxs-lookup"><span data-stu-id="7dc70-343">Module initializers are methods that have the <xref:System.Runtime.CompilerServices.ModuleInitializerAttribute> attribute attached to them.</span></span> <span data-ttu-id="7dc70-344">在整个模块中进行任何其他字段访问或方法调用之前，运行时将调用这些方法。</span><span class="sxs-lookup"><span data-stu-id="7dc70-344">These methods will be called by the runtime before any other field access or method invocation within the entire module.</span></span> <span data-ttu-id="7dc70-345">模块初始化表达式方法：</span><span class="sxs-lookup"><span data-stu-id="7dc70-345">A module initializer method:</span></span>

- <span data-ttu-id="7dc70-346">必须是静态的</span><span class="sxs-lookup"><span data-stu-id="7dc70-346">Must be static</span></span>
- <span data-ttu-id="7dc70-347">必须没有参数</span><span class="sxs-lookup"><span data-stu-id="7dc70-347">Must be parameterless</span></span>
- <span data-ttu-id="7dc70-348">必须返回 void</span><span class="sxs-lookup"><span data-stu-id="7dc70-348">Must return void</span></span>
- <span data-ttu-id="7dc70-349">不能是泛型方法</span><span class="sxs-lookup"><span data-stu-id="7dc70-349">Must not be a generic method</span></span>
- <span data-ttu-id="7dc70-350">不能包含在泛型类中</span><span class="sxs-lookup"><span data-stu-id="7dc70-350">Must not be contained in a generic class</span></span>
- <span data-ttu-id="7dc70-351">必须能够从包含模块访问</span><span class="sxs-lookup"><span data-stu-id="7dc70-351">Must be accessible from the containing module</span></span>

<span data-ttu-id="7dc70-352">最后一个要点实际上意味着该方法及其包含类必须是内部的或公共的。</span><span class="sxs-lookup"><span data-stu-id="7dc70-352">That last bullet point effectively means the method and its containing class must be internal or public.</span></span> <span data-ttu-id="7dc70-353">方法不能为本地函数。</span><span class="sxs-lookup"><span data-stu-id="7dc70-353">The method can't be a local function.</span></span> <span data-ttu-id="7dc70-354">有关详细信息，请参阅 [`ModuleInitializer` 属性](../language-reference/attributes/general.md#moduleinitializer-attribute)。</span><span class="sxs-lookup"><span data-stu-id="7dc70-354">For more information, see [`ModuleInitializer` attribute](../language-reference/attributes/general.md#moduleinitializer-attribute).</span></span>
